# -*- coding: utf-8 -*-
"""Anotaciones - CPD

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1neG2MUcfmYq8lKIW0bD08IA45Wg9_Jkn
"""

import threading

def sumar_parcial(numeros, resultado, indice):
    resultado[indice] = sum(numeros)

numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
num_hilos = 2
tamaño_parte = len(numeros) // num_hilos
resultados = [0] * num_hilos
hilos = []

for i in range(num_hilos):
    inicio = i * tamaño_parte
    fin = None if i + 1 == num_hilos else (i + 1) * tamaño_parte
    hilo = threading.Thread(target=sumar_parcial, args=(numeros[inicio:fin], resultados, i))
    hilos.append(hilo)
    hilo.start()

for hilo in hilos:
    hilo.join()

suma_total = sum(resultados)
print(f"Suma total: {suma_total}")

import asyncio
import random

async def calcular_cuadrado(numero):
    await asyncio.sleep(random.uniform(0.1, 0.5))  # Simula una operación I/O
    resultado = numero * numero
    print(f"El cuadrado de {numero} es {resultado}")
    return resultado

async def main():
    numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    tareas = [calcular_cuadrado(numero) for numero in numeros]

    resultados = await asyncio.gather(*tareas)

    suma_total = sum(resultados)
    print(f"Suma total de los cuadrados: {suma_total}")

# Este bloque es necesario para ejecutar el código en un entorno que ya tiene un bucle de eventos en ejecución.
if __name__ == "__main__":
    try:
        loop = asyncio.get_running_loop()
    except RuntimeError:  # No hay ningún bucle de eventos en ejecución
        loop = None

    if loop and loop.is_running():
        print("El bucle de eventos ya está corriendo. Ejecutando main() en un nuevo bucle.")
        task = loop.create_task(main())
        loop.run_until_complete(task)
    else:
        asyncio.run(main())

import multiprocessing

def sumar_parcial(numeros, resultado, indice):
    resultado[indice] = sum(numeros)

if __name__ == "__main__":
    numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90, 10]
    num_procesos = 2
    tamaño_parte = len(numeros) // num_procesos
    resultado = multiprocessing.Array('i', num_procesos)  # Array compartido
    procesos = []

    for i in range(num_procesos):
        inicio = i * tamaño_parte
        fin = (i + 1) * tamaño_parte if i != num_procesos - 1 else len(numeros)
        proceso = multiprocessing.Process(target=sumar_parcial, args=(numeros[inicio:fin], resultado, i))
        procesos.append(proceso)
        proceso.start()

    for proceso in procesos:
        proceso.join()

    suma_total = sum(resultado)
    print(f"Suma total: {suma_total}")

import multiprocessing
import math

def calcular_factorial(n, resultado, indice):
    resultado[indice] = math.factorial(n)

if __name__ == "__main__":
    numeros = [5, 7, 10, 12]
    num_procesos = len(numeros)
    resultado = multiprocessing.Array('i', num_procesos)  # Array compartido
    procesos = []

    for i, numero in enumerate(numeros):
        proceso = multiprocessing.Process(target=calcular_factorial, args=(numero, resultado, i))
        procesos.append(proceso)
        proceso.start()

    for proceso in procesos:
        proceso.join()

    resultados = list(resultado)
    print(f"Factoriales: {resultados}")

import multiprocessing

def es_primo(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def encontrar_primos(rango, resultado, indice):
    primos = [n for n in rango if es_primo(n)]
    resultado[indice] = primos

if __name__ == "__main__":
    rango_max = 100
    num_procesos = 4
    rango_por_proceso = rango_max // num_procesos
    resultado = multiprocessing.Manager().list([[] for _ in range(num_procesos)])  # Lista compartida
    procesos = []

    for i in range(num_procesos):
        inicio = i * rango_por_proceso + 1
        fin = (i + 1) * rango_por_proceso + 1
        proceso = multiprocessing.Process(target=encontrar_primos, args=(range(inicio, fin), resultado, i))
        procesos.append(proceso)
        proceso.start()

    for proceso in procesos:
        proceso.join()

    primos = [primo for sublist in resultado for primo in sublist]
    print(f"Números primos: {primos}")

import asyncio
import random

async def descargar_url(url):
    print(f"Descargando: {url}")
    await asyncio.sleep(random.uniform(0.5, 2.0))  # Simula la descarga
    contenido = f"Contenido de {url}"
    print(f"Descargado: {url}")
    return contenido

async def main():
    urls = [
        "http://example.com",
        "http://python.org",
        "http://asyncio.org",
        "http://aiohttp.org"
    ]

    tareas = [descargar_url(url) for url in urls]
    contenidos = await asyncio.gather(*tareas)

    for url, contenido in zip(urls, contenidos):
        print(f"Contenido de {url}: {contenido[:60]}")

if __name__ == "__main__":
    asyncio.run(main())

def calcular_descuento(precio, descuento):
    if descuento == '10%':
        return precio * 0.9
    elif descuento == '20%':
        return precio * 0.8
    elif descuento == '30%':
        return precio * 0.7
    else:
        return precio

print(calcular_descuento(100, '10%'))
print(calcular_descuento(100, '20%'))
print(calcular_descuento(100, '30%'))
print(calcular_descuento(100, '50%'))

def calcular_descuento(precio, descuento):
    descuentos = {
        '10%': 0.9,
        '20%': 0.8,
        '30%': 0.7
    }
    return precio * descuentos.get(descuento, 1)

print(calcular_descuento(100, '10%'))
print(calcular_descuento(100, '20%'))
print(calcular_descuento(100, '30%'))
print(calcular_descuento(100, '50%'))