# -*- coding: utf-8 -*-
"""Te damos la bienvenida a Colaboratory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

#Ejercicio 1 - Examen Parcial - CPD - Ames Anapán José Manuel

import multiprocessing

def sumar_parcial(numeros, resultado, indice):
    resultado[indice] = sum(numeros)

if __name__ == "__main__":
    numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90, 10]
    num_procesos = 2
    tamaño_parte = len(numeros) // num_procesos
    resultado = multiprocessing.Array('i', num_procesos)  # Array compartido
    procesos = []

    for i in range(num_procesos):
        inicio = i * tamaño_parte
        fin = (i + 1) * tamaño_parte if i != num_procesos - 1 else len(numeros)
        proceso = multiprocessing.Process(target=sumar_parcial, args=(numeros[inicio:fin], resultado, i))
        procesos.append(proceso)
        proceso.start()

    for proceso in procesos:
        proceso.join()

    suma_total = sum(resultado)
    print(f"Suma total: {suma_total}")



#Ejercicio 2 - Examen Parcial - CPD - Ames Anapán José Manuel

import concurrent.futures

def square(x):
    return x * x

with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:

     fut1 = executor.submit(square, 2)
     fut2 = executor.submit(square, 3)

concurrent.futures.wait([fut1, fut2])

    results_with_wait = [fut1.result(), fut2.result()]


print(\"Eresultados obtenidos usando wait:\", results_with_wait)


    fut1 = executor.submit(square, 2)
    fut2 = executor.submit(square, 3)

results = concurrent.futures.as_completed([fut1, fut2])
results_list_as_completed = [future.result() for future in results]


print(\"Resultados obtenidos usando as_completed:\", results_list_as_completed)



#Ejercicio 3 - Examen Parcial - CPD - Ames Anapán José Manuel

import asyncio
import random

async def descargar_url(url):
    print(f"Descargando: {url}")
    await asyncio.sleep(random.uniform(0.5, 2.0))  # Simula la descarga
    contenido = f"Contenido de {url}"
    print(f"Descargado: {url}")
    return contenido

async def main():
    urls = [
        "http://example.com",
        "http://python.org",
        "http://asyncio.org",
        "http://aiohttp.org"
    ]

    tareas = [descargar_url(url) for url in urls]
    contenidos = await asyncio.gather(*tareas)

    for url, contenido in zip(urls, contenidos):
        print(f"Contenido de {url}: {contenido[:60]}")

if __name__ == "__main__":
    asyncio.run(main())

def calcular_descuento(precio, descuento):
    if descuento == '10%':
        return precio * 0.9
    elif descuento == '20%':
        return precio * 0.8
    elif descuento == '30%':
        return precio * 0.7
    else:
        return precio

print(calcular_descuento(100, '10%'))
print(calcular_descuento(100, '20%'))
print(calcular_descuento(100, '30%'))
print(calcular_descuento(100, '50%'))

def calcular_descuento(precio, descuento):
    descuentos = {
        '10%': 0.9,
        '20%': 0.8,
        '30%': 0.7
    }
    return precio * descuentos.get(descuento, 1)

print(calcular_descuento(100, '10%'))
print(calcular_descuento(100, '20%'))
print(calcular_descuento(100, '30%'))
print(calcular_descuento(100, '50%'))



#Ejercicio 4 - Examen Parcial - CPD - Ames Anapán José Manuel

import time,
def time_it(func):
    def wrapper(*args, **kwargs):
        start = time.time()\n",
        result = func(*args, **kwargs)\n",
        end = time.time()\n",
        print(f\"{func.__name__} tomó {end - start} segundos en ejecutarse.\")\n",
        return result\n",
    return wrapper\n",

@time_it
def my_function()
    time.sleep(1)
my_function()



#Ejercicio 5 - Examen Parcial - CPD - Ames Anapán José Manuel

import threading
def cocinar_plato(nombre):
    print(f Cocinando {nombre}...)

hilo1 = threading.Thread(target=cocinar_plato, args=(causa,))
hilo2 = threading.Thread(target=cocinar_plato, args=(ceviche,))

hilo1.start()
hilo2.start()

hilo1.join()
hilo2.join()

print(Todos los platos están listos!)


#Ejercicio 7 - Examen Parcial - CPD - Ames Anapán José Manuel


a) ¿Cómo podrías asegurarte de que el servidor se cierra correctamente al recibir una señal de interrupción (por ejemplo, Ctrl+C)? Implementa un manejador de señales para limpiar
recursos y cerrar el servidor de manera ordenada.

- Podría asegurarme que el servidor se cierra de manera correcta mediante la utilización de librerías que se encarguen de examinar los archivos del servidor antes que se cierre.

b) ¿Cómo podrías utilizar funciones parciales para mejorar la legibilidad y la gestión de
parámetros en el código? Utiliza functools.partial para simplificar la creación de funciones con múltiples parámetros predefinidos.

- Podría utilizar la función functools.partial, ya que no solo simplifica la creación de varias funciones sino que también agiliza el funcionamiento de varios puntos que no tienen una denominación.

c) ¿Cómo puedes inicializar adecuadamente los trabajadores y gestionar un pool de procesos,
asegurando que se ignoren ciertas señales en los trabajadores? Utiliza mp.Pool con un
inicializador que configure la gestión de señales apropiadamente en los procesos hijos.

-Con la función Multiprocesos o en los programas conocida como Multiprocessing, esta función es importante porque nos ayuda a gestionar de manera eficiente los hilos o threads, además que nos ofrece gran variedad de aportaciones matemáticas.

d) ¿Cómo aseguras que los trabajadores terminan correctamente cuando se cierra el servidor?
Envia un trabajo especial (sentinela) a los trabajadores para indicarles que deben finalizar.
No te olvides de que los hilos trabajadores se unen adecuadamente antes de que el
programa principal termine.

- Aseguro que se realiza el debido trabajo a través de los hilos, porque nos indican a tener una secuenciación del código en todo momento, además que nos ayuda a identificar si se está equivocando o haciendo mal una tarea.

e) ¿Cómo manejas adecuadamente las excepciones y errores para asegurarte de que el
servidor no falle de manera inesperada? Captura y maneja las excepciones en las funciones
asincrónicas y en los hilos trabajadores. Utiliza bloques try-except para manejar errores en la comunicación entre el cliente y el servidor.

- Lo manejo utilizando diversas librerías que me apoyen en el monitoreo mediante try-except para manejar las equivocaciones entre el sistema y el usuario.

f) ¿Cómo puedes mejorar la estructura general y la legibilidad del código para hacerlo más
mantenible y robusto?. Refactoriza el código para separar claramente las responsabilidades
(por ejemplo, manejar trabajos, manejar resultados, aceptar solicitudes). Utiliza nombres de
variables y funciones descriptivos para mejorar la claridad del código.

El código re-factorizado por ejemplo cuando creamos códigos donde ameriten los resultados como listas, donde los datos factoriales se encuentren a raíz de rango, resultado e índice. Mejoramos la estructura general mediante la re factorización para poder tener un seguimiento de los procesos, resultados como se mencionó anteriormente y trabajos.